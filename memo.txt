@ 파일지울때 한번에 안 지워질땐 당연히 외부참조 클래스부터 순차삭제

# 클래스
- 클래스는 객체를 기술하는 문법, 설계도, 명세 / 객체는 추상체, 단위 / 모든 인스턴스는 객체(클래스의 인스턴스)
(클래스는 설계도, 객체는 마우스 제품, 인스턴스는 내 마우스)

# 참조
- 매개변수로 참조값을 받으면 매개변수에 해당하는 인스턴스도 메모리에 생성(* ref.MC2)

# oop
- 실생활의 사물(object)들로 개발을 하듯이

# 생성자
- IDE 발달로 this 생략도 많이 사용함
- 기본 생성자는 개발자의 편의를 위해

# 패키지
- 계층구조를 이루더라도 모두 별개

# 메모리
- 외부 참조가 풀린 후 힙 내부에서 인스턴스끼리 참조하는 것도 GC대상

# static
- 가끔 main안에 넣어서 이슈있던건 main이 static여서 그런 경우도 있음

# final
- final 필드 초기화시 메모리 중복의 관점에서 static이 일반적
- 참조값 final의 경우 조심

# 상속
- 화살표는 '내가 arrow를 안다'의 뜻
- 서로 다른 패키지간 상속도 가능(이 경우 protected 사용 가능)

* 자식 인스턴스 생성시 힙 메모리 상에 모든 부모의 필드 정보도 동시 생성(따라서 인스턴스 생성시 부모+자식 필드의 메모리 영역을 차지)
> 따라서 메소드 호출시 변수의 타입을 기준으로 상속 관계 인스턴스 중 메소드를 선택하여 호출
(인스턴스 생성시 1 필드값 2 가상 메서드 테이블 을 갖고 이 중 2를 사용)
> 본인 타입에서 호출 불가시 부모 인스턴스 메소드 호출(반대는 불가) - 이 부분에서 인터페이스와 차이 중요

- 오버라이딩시 접근제어자는 넓어지는건 가능, 좁아지는건 불가능
- 당연히 static(상속은 인스턴스 레벨), final, private(자식에게도 숨김)는 오버라이딩 불가

- 생성자에서 this()를 사용하더라도 반드시 super()가 호출되어야한다.

# 다형성
- 물리적으론 하나의 인스턴스 생성이지만 논리적으론 부모~자식 인스턴스 모두 생성된다고 보는게 이후 학습에 편함

# 다형성 - 캐스팅
- 인스턴스 뿐만아니라 참조값끼리도 다형성이 적용
- 캐스팅을 하면 인스턴스의 타입은 안 변하고 '참조값'의 타입이 변하는 것
- instanceof도 업캐스팅마냥 부모 허용(헷갈리면 참조값으로 사용해보면 쉬움)
- 개념적으로 업캐스팅은 필요없지만 문법상으론 업캐스팅이 생략
- (자바16) Pattern Matching for instanceof - poly.basic.CastingMain6 참조

# 다형성 - 오버라이딩
- 다형성에서 오버라이딩된 메서드는 항상 우선권(마치 기본 문법상 자식 > 부모 순차 호출처럼)
> 오버라이딩이 아닌 필드값의 경우엔 당연히 기본 문법을 따르며 중복시 참조 타입을 따름(ex03 참고)

# 다형성 - 추상클래스
- 추상클래스는 일반 클래스의 자식으로도 상속 가능

# 인터페이스
- 순수추상클래스(자바엔 없는 개념) + 다중 구현 + 오버라이딩 제약 = 인터페이스
- 클래스, 추상클래스, 인터페이스 모두 코드/메모리 구조상 동일(기능 제약)

# OCP
- 새로운 코드(확장)는 open 기존 코드는 closed - 전략 패턴이 대표적인 예(car 참조)