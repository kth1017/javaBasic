@ 파일지울때 한번에 안 지워질땐 당연히 외부참조 클래스부터 순차삭제

# 클래스
- 클래스는 객체를 기술하는 문법, 설계도, 명세 / 객체는 추상체, 단위 / 모든 인스턴스는 객체(클래스의 인스턴스)
(클래스는 설계도, 객체는 마우스 제품, 인스턴스는 내 마우스)

# 참조
- 매개변수로 참조값을 받으면 매개변수에 해당하는 인스턴스도 메모리에 생성(* ref.MC2)

# oop
- 실생활의 사물(object)들로 개발을 하듯이

# 생성자
- IDE 발달로 this 생략도 많이 사용함
- 기본 생성자는 개발자의 편의를 위해

# 패키지
- 계층구조를 이루더라도 모두 별개

# 메모리
- 외부 참조가 풀린 후 힙 내부에서 인스턴스끼리 참조하는 것도 GC대상

# static
- 가끔 main안에 넣어서 이슈있던건 main이 static여서 그런 경우도 있음

# final
- final 필드 초기화시 메모리 중복의 관점에서 static이 일반적
- 참조값 final의 경우 조심

# 상속
- 화살표는 '내가 arrow를 안다'의 뜻
- 서로 다른 패키지간 상속도 가능(이 경우 protected 사용 가능)

* 자식 인스턴스 생성시 힙 메모리 상에 모든 부모의 필드 정보도 동시 생성(따라서 인스턴스 생성시 부모+자식 필드의 메모리 영역을 차지)
> 따라서 메소드 호출시 변수의 타입을 기준으로 상속 관계 인스턴스 중 메소드를 선택하여 호출
(인스턴스 생성시 1 필드값 2 가상 메서드 테이블 을 갖고 이 중 2를 사용)
> 본인 타입에서 호출 불가시 부모 인스턴스 메소드 호출(반대는 불가) - 이 부분에서 인터페이스와 차이 중요

? 구현시 인터페이스 변수 타입일때의 다형성

- 오버라이딩시 접근제어자는 넓어지는건 가능, 좁아지는건 불가능
- 당연히 static(상속은 인스턴스 레벨), final, private(자식에게도 숨김)는 오버라이딩 불가

- 생성자에서 this()를 사용하더라도 반드시 super()가 호출되어야한다.
